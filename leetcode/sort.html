<!DOCTYPE html>
    <html>
        <head>
            <meta charset="UTF-8">
            <title>排序算法实战</title>
            <style type="text/css"></style>
            <script type="text/javascript">
                // 冒泡
                function bubbleSort(arr) {
                    let len = arr.length;
                    if (len <= 0) {
                        return [];
                    }
                    // 从大到小排列
                    for (let i = 0; i < len - 1; i++) {
                        let swaped = false;
                        for (let j = i + 1; j < len; j++) {
                            if (arr[i] < arr[j]) {
                                swaped = true;
                                let temp = arr[j];
                                arr[j] = arr[i];
                                arr[i] = temp;
                            }
                        }
                        if (!swaped) {
                            return arr;
                        }
                    }
                    return arr;
                }
                var a = [3, 4, 8, 2, 7];
                console.log('冒泡排序', bubbleSort(a));

                // 插入排序，从小到大：在已经排序的元素序列中从后向前扫描，保存当前值arr[i]，必要的时候，需要平移数组的值
                function insertSort(arr) {
                    let len = arr.length;
                    if (len <= 0) {
                        return [];
                    }
                    for (let i = 1; i < len; i++) {
                        let temp = arr[i];
                        let j = i - 1;
                        while (j >= 0 && arr[j] > temp) {
                            arr[j + 1] = arr[j];
                            --j;
                        }
                        arr[j + 1] = temp;
                    }
                    console.log('insertSort arr = ', arr);
                    return arr;
                }
                insertSort([3, 5, 1, 7]);

                // 选择排序，从小到大：选择最小值，交换
                function chooseSort(arr) {
                    let len = arr.length;
                    if (len <= 0) {
                        return [];
                    }
                    let minIndex, temp;
                    for (let i = 0; i < len; i++) {
                        minIndex = i;
                        for (let j = i + 1; j < len; j++) {
                            if (arr[minIndex] > arr[j]) {
                                minIndex = j;
                                console.log('minIndex = ', minIndex);
                            }
                        }
                        temp = arr[i];
                        arr[i] = arr[minIndex];
                        arr[minIndex] = temp;
                    }
                    console.log('results = ', arr);
                    return arr;
                }
                chooseSort([3, 5, 1, 7]);

                console.log('********************归并排序************************');
                // 归并排序：分为左右两部分，循环递归到只有一个数据
                function mergeSort(arr) {
                    let len = arr.length;
                    if (arr.length <= 1) {
                        return arr;
                    }
                    let mid = Math.floor(len / 2);
                    let leftArr = arr.slice(0, mid);
                    let rightArr = arr.slice(mid);
                    console.log('归并排序 left =', leftArr, 'right = ', rightArr);
                    return mergeSortInner(mergeSort(leftArr), mergeSort(rightArr));
                }
                function mergeSortInner(left, right) {
                    let reuslt = [];
                    while (left.length && right.length) {
                        if (left[0] <= right[0]) {
                            reuslt.push(left.shift());
                        }
                        else {
                            reuslt.push(right.shift());
                        }
                    }
                    while (left.length) {
                        reuslt.push(left.shift());
                    }
                    while (right.length) {
                        reuslt.push(right.shift());
                    }
                    console.log('归并排序耗时', reuslt);
                    return reuslt;
                }
                console.log('result  =', mergeSort([3, 5, 1, 7, 2]));

                console.log('********************快速排序************************');
                // 快速排序
                function quickSort(arr) {
                    let len = arr.length;
                    if (arr.length <= 1) {
                        return arr;
                    }
                    let privotIndex = Math.floor(len / 2);
                    let pivot = arr.splice(privotIndex, 1)[0];
                    let left = [];
                    let right = [];
                    for (let i = 0; i < arr.length; i++) {
                        if (arr[i] < pivot) {
                            left.push(arr[i]);
                        }
                        else {
                            right.push(arr[i]);
                        }
                    }
                    return quickSort(left).concat([pivot], quickSort(right));
                    // return quickSort(left).concat(pivot, quickSort(right));
                }
                console.log('快速排序 quickSort = ', quickSort([3, 5, 2, 4, 7, 1]));

                console.log('******************** 希尔排序 ************************');
                // 中心思想：动态缩小gap，直到gap = 1，说明所有的都已经有序
                // 第一步gap = len / 2，for循环遍历gap
                function shellSort(arr) {
                    let len = arr.length;
                    if (arr.length <= 1) {
                        return arr;
                    }
                    // 第一步，找到合适的gap
                    let gap = 1;
                    while (gap < len / 2) {
                        gap = gap * 2 + 1;
                    }
                    // 最外层，修改gap
                    for (;gap >= 1; gap = Math.floor(gap / 2)) {
                        console.log('gap =', gap, 'arr = ', arr);
                        // 从i = gap处开始向后遍历
                        for (let i = gap; i < len; i++) {
                            console.log('i =', i);
                            let temp = arr[i];
                            let prev = i - gap;
                            // 从i-gap开始，一直将i-gap，到
                            for (; prev >= 0 && arr[prev] > temp;) {
                                console.log('prev =', prev);
                                arr[prev + gap] = arr[prev];
                                prev = prev - gap;
                            }
                            arr[prev + gap] = temp;
                        }
                    }
                    return arr;
                }
                console.log('希尔排序 shellSort = ', shellSort([3, 5, 2, 4, 7, 1]));
            </script>
        </head>
        <body>
            <h2>排序算法</h2>
        </body>
        <script>
            // document.getElementById('a').addEventListener('click', function(e) {
            //     console.log('target:' + e.target.id + ' &currentTarget:' + e.currentTarget.id);
            // });
            // document.getElementById('b').addEventListener('click', function(e) {
            //     console.log('target:' + e.target.id + ' currentTarget:' + e.currentTarget.id);
            // });
            // document.getElementById('c').addEventListener('click', function(e) {
            //     console.log('target:' + e.target.id + ' currentTarget:' + e.currentTarget.id);
            // });
            // document.getElementById('d').addEventListener('click', function(e) {
            //     console.log('target:' + e.target.id + ' currentTarget:' + e.currentTarget.id);
            // });
            console.log('******************** 归并排序2 ************************');
            // 归并排序
            var merge = function(intervals) {
                let len = intervals.length;
                if (len <= 1) {
                    return intervals;
                }
                intervals.sort(sortArr);
                console.log('ingervals = ', intervals);
                let result = [];
                // 暴力
                for (let i = 0; i < len;) {
                    let temp = intervals[i];
                    let tempIndex = i;
                    // console.log('i = ', i, 'temp = ', temp);
                    for (let j = i + 1; j < len; j++) {
                        let left = Math.min(temp[0], intervals[j][0]);
                        let right = Math.max(temp[1], intervals[j][1]);
                        if (left <= right) {
                            temp = [left, right];
                            tempIndex = j;
                        }
                        // if (temp[1] >= intervals[j][0] && temp[0] < intervals[j][1]) {
                        // }
                        else {
                            break;
                        }
                    }
                    result.push(temp);
                    i = tempIndex + 1;
                }
                // 递归
                // if (intervals[0][1] > intervals[1][0]) {
                //     intervals.splice(0, 2, [intervals[0][0], intervals[1][1]])
                //     result = merge(intervals);
                // }
                // else {
                //     console.log('result = ', result);
                //     return result;
                // }
                // for (let i = 0; i < len - 1;) {

                // }
                console.log('result = ', result);
                return result;
            };
            var sortArr = function(a, b) {
                return a[0] - b[0];
            }
            // merge([[1,3],[2,6],[3, 7], [8,10],[15,18]]);
            // merge([[1,3], [15,18]]);
            // merge([[1, 4], [0, 4]]);
            merge([[1, 4], [0, 0]]);
            // merge([[1, 4], [0, 1]]);
            // merge([[2,3],[4,5],[6,7],[8,9],[1,10]]);

            // 二分法
            function binarySearch(arr, target) {
                let len = arr.length;
                if (len === 0) {
                    return -1;
                }
                let low = 0;
                let high = len - 1;
                // let mid = 0;
                while (low <= high) {
                    let mid = Math.floor((high - low) / 2) + low;
                    // console.log('mid = ', mid);
                    if (arr[mid] === target) {
                        // 要求返回第一个下标
                        while(mid !== 0 && arr[mid] === arr[mid - 1]) {
                            --mid;
                        }
                        console.log('result = ', mid);
                        return mid;
                    }
                    console.log('low =', low, 'high = ', high);
                    if (low === high) {
                        console.log('result = ', -1);
                        return -1;
                    }
                    if (arr[mid] < target) {
                        low = mid + 1;
                    } else {
                        high = mid;
                    }
                }
                console.log('result = ', -1);
                return -1;
            }
            // binarySearch([3, 4, 7, 20, 44, 50], 3);
            // binarySearch([3, 4, 7, 20, 44, 50], 4);
            // binarySearch([3, 4, 7, 20, 44, 50], 7);
            // binarySearch([3, 4, 7, 20, 44, 50], 20);
            // binarySearch([3, 4, 7, 20, 44, 50], 44);
            // binarySearch([3, 4, 7, 20, 44, 50], 50);
            // binarySearch([3, 4, 7, 20, 44, 50], 1);
            // binarySearch([3, 4, 7, 20, 44, 50], 70);
            // binarySearch([3, 4, 7, 20, 44], 3);
            // binarySearch([3, 4, 7, 20, 44], 4);
            // binarySearch([3, 4, 7, 20, 44], 7);
            // binarySearch([3, 4, 7, 20, 44], 20);
            // binarySearch([3, 4, 7, 20, 44], 44);
            // binarySearch([3, 4, 7, 20, 44], 1);
            // binarySearch([3, 4, 7, 20, 44], 70);
            binarySearch([3, 4, 7, 20, 44], 10);
            binarySearch([1, 2, 2, 3, 4], 2);

            function mergeSort2(arr) {
                let len = arr.length;
                if (len <= 1) {
                    return arr;
                }
                let mid = Math.floor(len / 2);
                return mergeSortInner2(mergeSort2(arr.slice(0, mid)), mergeSort2(arr.slice(mid)));
            }
            function mergeSortInner2(left, right) {
                let result = [];
                while (left.length && right.length) {
                    if (left[0] <= right[0]) {
                        result.push(left.shift());
                    } else {
                        result.push(right.shift());
                    }
                }
                if (left.length) {
                    result = result.concat(left);
                }
                if (right.length) {
                    result = result.concat(right);
                }
                return result;
            }
            console.log('6.22测试 归并排序', mergeSort2([5, 3, 1, 7]));
            console.log('6.22测试 归并排序', mergeSort2([5, 3, 1, 7, 3]));
            console.log('6.22测试 归并排序', mergeSort2([5, 3]));

            // 快排--递归
            function quickSort2(arr) {
                let len = arr.length;
                if (len <= 1) {
                    return arr;
                }
                let left = [];
                let right = [];
                let partitionIndex = Math.floor(len / 2);
                let pivot = arr[partitionIndex];
                for (let i = 0; i < len; i++) {
                    if (i === partitionIndex) {
                        continue;
                    }
                    if (arr[i] < pivot) {
                        left.push(arr[i]);
                    } else {
                        right.push(arr[i]);
                    }
                }
                return quickSort2(left).concat([pivot], quickSort2(right));
            }
            console.log('6.22测试 快速排序', quickSort2([5, 3, 1, 7]));
            console.log('6.22测试 快速排序', quickSort2([5, 3, 1, 7, 3]));

            function mergeSort3(arr) {
                let len = arr.length;
                console.log('arr = ', arr);
                if (len <= 1) {
                    return arr;
                }
                let mid = Math.floor(len / 2);
                let left = arr.slice(0, mid);
                let right = arr.slice(mid);
                return merge3(mergeSort3(left), mergeSort3(right));
            }
            function merge3(left, right) {
                let leftLen = left.length;
                let rightLen = right.length;
                let i = 0;
                let j = 0;
                let result = [];
                while (i < leftLen && j < rightLen) {
                    if (left[i] <= right[j]) {
                        result.push(left[i]);
                        i++;
                    } else {
                        result.push(right[j]);
                        j++;
                    }
                }
                while (i < leftLen) {
                    result.push(left[i]);
                    i++;
                }
                while (j < rightLen) {
                    result.push(right[j]);
                    j++;
                }
                return result;
            }
            console.log('6.23测试 归并排序', mergeSort3([5, 3, 1, 7, 3]));

            // 希尔排序
            function shellSort3(arr) {
                let len = arr.length;
                console.log('arr = ', arr);
                if (len <= 1) {
                    return arr;
                }
                // gap
                let gap = Math.floor(len / 2);
                for (; gap >= 1; gap = Math.floor(gap / 2)) {
                    console.log('gap =', gap, 'arr = ', arr);
                    // 实现了一次遍历
                    for (let i = gap; i < len; i++) {
                        console.log('i =', i, 'arr = ', arr);
                        let prev = i - gap;
                        let temp = arr[i];
                        while (prev >= 0 && arr[prev] > temp) {
                            console.log('prev =', prev);
                            arr[prev + gap] = arr[prev];
                            prev = prev - gap;
                        }
                        arr[prev + gap] = temp;
                    }
                }
                return arr;
            }
            console.log(shellSort3([5, 1, 4, 3, 7]));

            // 对象数组排序：Array.sort()是默认按照字符串排列的，所以要针对字符串类型和数字类型的值，分别排序
            function compare(prop) {
                return function (obj1, obj2) {
                    var val1 = obj1[prop];
                    var val2 = obj2[prop];
                    if (!isNaN(Number(val1)) && !isNaN(Number(val2))) {
                        val1 = Number(val1);
                        val2 = Number(val2);
                    }
                    // return val1 - val2; // 如果直接返回val1 - val2，比较字符串是错误的，比较数字时，结果正确，倒叙排列

                    // 比较字符串\数字，都是正确的，返回都是正序排列
                    if (val1 < val2) {
                        return -1;
                    } else if (val1 > val2) {
                        return 1;
                    } else {
                        return 0;
                    }            
                };
            }
            let obj1 = [{name: 'bbbb', age: 22, score: 100},
                {name: 'cccc', age: 18, score: 90},
                {name: 'aaaa', age: 9, score: 80},];
            // console.log('对象数组排序 ', obj1.sort(compare('name')));
            console.log('对象数组排序 ', obj1.sort(compare('score')));
        </script>
    </html>