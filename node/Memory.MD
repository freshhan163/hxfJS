# JS的垃圾回收机制

## 目录
* 1.基础
    * 1.1 为什么会有垃圾回收机制？
    * 1.2 什么情况会引起内存泄露？
    * 1.3 JS中栈内存和堆内存是如何分配的？什么样的放到堆内存，什么样的放到栈内存？
    * 1.4 V8引擎的内存分配图？堆空间的组成？
    * 1.5 新生代 | 老生代默认分配的内存是多少？为什么会是这些？
* 2.垃圾回收策略
    * 2.1 如何判断变量是否可以回收？
    * 2.2 垃圾回收策略
        * 新生代算法：Scavenge算法
        * 老生代算法：Mark-sweep（标记清除） | Mark-compact（标记整理）
            * 广度扫描 --> 全停顿标记 --> 增量标记&三色标记法 -->  
    * 2.3 标记清除和标记整理中 的标记算法
    * 2.4 老版本IE使用的算法--引用计数（已经废弃），引用计数的算法、弊端有哪些？为什么要废弃？
    * 2.5 老生代回收算法，为什么要使用两种方式结合，什么情况下用什么算法？（Mark-Sweep和 Mark-Compact）
* 3.扩展
    * 3.1 全局变量会被清除吗？局部变量不使用后，会立即被清除吗？
    * 3.2 如何修改node默认内存？如何查看chrome | node当前占用内存？
    * 3.3 weakMap | weakSet为什么能被GC
* 问题
    * 新生代算法
    * 新生代如何晋升到老生代？
    * 为什么老生代是连续的内存空间？
    * 标记清除算法--详细过程
    * 标记整理算法--详细过程
    * 标记清楚和标记整理有什么不一样？是先清除再整理，还是先整理再清除？

chrome和Node底层 用的都是V8引擎，所以是一样的；

## 1.基础
### 1.1 为什么会有垃圾回收机制？
V8引擎底层是用C++语言写的，C++语言在定义变量的时候需要手动分配内存，不用后再手动去释放内存；
JS中内存的分配和释放是由V8引擎自动帮我们做的，如果只分配不回收，那内存很快就被占用满了，所以要有垃圾回收机制。

### 1.2 JS中什么情况会引起内存泄露呢？
全局变量不会被垃圾回收；
闭包引用过多；
事件监听未移除，或重复监听；

### 1.3 JS中栈内存和堆内存是如何分配的？什么样的放到堆内存，什么样的放到栈内存？
这个需要单独看，可参考文章（https://juejin.cn/post/6844903873992196110#heading-1）
也可参考文章（https://www.zhihu.com/question/482433315/answer/2083349992）

### 1.4 V8引擎的内存分配图？堆空间的组成？

### 1.5 新生代 | 老生代默认分配的内存是多少？为什么会是这些？
Node 14以下：

| 区分 | 新生代 | 老生代 | 总空间 |
| 64位 | 32MB | 1400MB | 1.4G（1433MB）|
| 32位 | 16MB | 700MB | 0.7G（716MB）|

Node 14以上，总空间已经升级到2GB。

备注：新生代内部又严格划分为2个相等内存空间（from和to），每个from和to都是各占一半的空间；老生代是一个连续的内存空间，又分为指针空间 和 数据空间

为什么只分配了这些空间？

因为JS诞生之初，只是为了渲染页面的，它是非持久化的语言，占用空间过大的场景基本上不会遇到，就没有设置太大；

另外，JS是异步单线程的，垃圾回收的时候JS是停止执行的，如果垃圾回收时间过长肯定会造成卡顿现象；

根据V8引擎的资料，如果回收1次1.5G以上的堆内存，需要50ms以上的时间。所以如果分配的内存过大，垃圾回收的时候就需要花费过多的时间。

现在可能会遇到Node读写大文件（超过2GB）,这时怎么办？？？？
可以修改默认分配的内存空间：node max-old-space-size（默认是MB）

JS垃圾回收的时机是没法控制的，在达到一个阈值后，由浏览器自动分配。

## 2.垃圾回收策略
### 2.1 如何判断变量是否可以回收？
标记清除（Mark-Sweep）：
* 进入堆内存的所有变量都加上标记
* 取消标记：去掉运行环境中的全局变量和被引用变量的标记
* 依然有标记的变量，就会被下次垃圾回收的时候删除
* 删除变量，销毁他们占用的内存空间。

引用计数：
* 变量进入环境，并被赋值的时候，引用计数为1
* 每被引用1次，引用次数+1；如果对这个值引用的变量改变了对它的引用，那计数 - 1；
* 删除引用计数是0的变量

### 2.2 垃圾回收策略

采用分代回收策略，分为新生代 | 老生代两种；
新生代存放生存周期较短的变量，新生代的变量后期会晋升到老生代中。

新生代回收策略：Scavenge算法
* 新生代内存，在64位机器中，只有64MB，它又严格分为两块相等的空间From和To，每块内存只占32MB；
* 变量一开始一般都存放在新生代中的，等满足一定条件后，会晋升到 老生代空间。
* 当然如果新生代内存空间不够，也会被直接分配到老生代！！！。
* 初始化运行时，新进入环境的变量，会先放在新生代的From中，此时To空间是闲置的。
* 当新生代的From空间快慢的时候，会进行一次垃圾回收，直接将From空间存活的变量 COPY到 To空间中，然后清除From空间，再对调 From 和 To空间，下次进入新生代空间的变量仍然会放到From空间。

总结：
* 复制时，采用广度优先遍历算法。
* 新生代为什么采用复制的形式？是用空间换时间，Copy方法是最简单最快的，以64bit电脑举例，有32MB空间始终是闲置的，用32MB的空间换时间是比较划算的。
* 代码删除变量后，不是立马删除，只是打了个标记；等到垃圾回收的时候，内存中的变量才会真正删除。

新生代晋升老生代的条件(两个条件都要具备！)：
* 对象已经经历一次 Scavage回收；
* 如果To空间已经使用了超过25%，对象就会直接晋升到老生代；


老生代回收策略

老生代为什么不用复制的策略？
因为老生代空间占用1400MB，折半的话也是700MB，随着变量越来越多，变量会逐渐被存放到老生代中，需要的空间也越来越大，这时候用空间换时间，是很不明智的选择。

* 标记清除：
GC是有一个根节点的，从根节点开始，进行广度搜索，遇到被引用的变量，就会标记；等垃圾回收的时候，就会清除掉不用的变量。
备注：新生代只复制存活--被引用的变量。老生代只清除不被引用的变量，新生代中存活的变量较少，老生代中不用的变量较多。

* 标记整理：
通过标记整理删除不用的变量后，会产生很多碎片，内存空间有点被浪费，如果出现要分配一个较大内存的情况，就会不满足分配，提前触发垃圾回收机制，但这次回收机制是不必要的。
所以在老生代内存空间不够用的时候，V8引擎就会使用标记整理算法，先标记，然后整理内存，将仍然被引用的变量整理成连续的空间，再清除掉不再引用的变量。

先整理，再清除：整理的过程中，就能清除一些不用的变量了，节省时间。


### 2.3 标记清除和标记整理中 的标记算法

标记算法：全停顿标记 和 增量标记&三色标记算法

全停顿标记算法：JS是单线程的，所以JS执行过程中会在主线程和垃圾回收线程之间切换，一次遍历，找到所有存活的变量，并打上标记；

增量标记：V8引擎中，线程切换更快，标记的层数会更少，且会改变下次遍历的根节点；每次标记时间更少，让卡顿时间更少。

三色标记：在增量标记的时候，灰色--表示已经被扫描了，下次要扫描的时候从这里开始，黑色：下次要扫描根节点的子节点。白色--已经扫描过，标记为存活的变量，下次不会再扫描了。


### 2.4 引用计数的弊端

”循环引用“的变量会一直被保存在内存中，无法被清除。

### 2.5 老生代回收算法，为什么要使用两种方式结合？

老生代回收算法，采用 Mark-Sweep 和 Mark-Compact 结合的方式；一般使用的是 Mark-Sweep，因为 Mark-Compact虽然提高了空间利用率，但耗费时间较长。

当内存空间不足的时候，会使用 Mark-Compact，整理空间。

### 2.6 为什么老生代需要连续的内存空间？


## 3 扩展
### 3.1 全局变量会被清除吗？局部变量不使用后，会立即被清除吗？

全局变量不会被清除，会存活到程序运行结束。

局部变量不使用后，不是立即被清除，而是先标记为不被使用的，等触发垃圾回收机制的时候，才从内存中删除。

### 3.2 如何修改node默认内存？如何查看chrome | node当前占用内存？

修改Node默认内存空间：
``` node max-old-space-size=4333```，老生代默认是MB，一般max-old-space-size，只能接受空闲内存的 75%；可用os.freemem来查看一下
``` node max-new-space-size=4333```，新生代默认是 KB

浏览器查看内存空间：   ```window.performance.memory```

Node查看内存空间： ```process.memoryUsage()```

### 3.3 weakMap | weakSet为什么能被GC

参考文档：https://es6.ruanyifeng.com/#docs/set-map#WeakMap